{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions",["flow",{}],"nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}]],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"sourceFileName":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","filename":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","passPerPreset":false,"envName":"development","cwd":"/home/benoit/Documents/TutoMeteor","root":"/home/benoit/Documents/TutoMeteor","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.7.6","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"TSModuleBlock":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue"}},"code":"var _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default: function (v) {\n    _objectSpread = v;\n  }\n}, 0);\n\nvar _objectWithoutProperties;\n\nmodule.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n  default: function (v) {\n    _objectWithoutProperties = v;\n  }\n}, 1);\n\nvar _inheritsLoose;\n\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 2);\nvar Vue;\nmodule.link(\"vue\", {\n  \"default\": function (v) {\n    Vue = v;\n  }\n}, 0);\nvar Aframe;\nmodule.link(\"aframe\", {\n  Aframe: function (v) {\n    Aframe = v;\n  }\n}, 1);\nvar Object;\nmodule.link(\"./Object.vue\", {\n  \"default\": function (v) {\n    Object = v;\n  }\n}, 2);\nvar Model;\nmodule.link(\"./Model.vue\", {\n  \"default\": function (v) {\n    Model = v;\n  }\n}, 3);\nVue.config.ignoredElements = ['a-scene', 'a-entity', 'a-camera', 'a-box', 'a-sky', 'a-sphere', 'a-cylinder', 'a-plane', 'a-gltf-model']; //Aframe\n\nvar ProjectedMaterial =\n/*#__PURE__*/\nfunction (_THREE$ShaderMaterial) {\n  _inheritsLoose(ProjectedMaterial, _THREE$ShaderMaterial);\n\n  function ProjectedMaterial() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var camera = _ref.camera,\n        texture = _ref.texture,\n        _ref$color = _ref.color,\n        color = _ref$color === void 0 ? 0xffffff : _ref$color,\n        options = _objectWithoutProperties(_ref, [\"camera\", \"texture\", \"color\"]);\n\n    if (!texture || !texture.isTexture) {\n      throw new Error('Invalid texture passed to the ProjectedMaterial');\n    }\n\n    if (!camera || !camera.isCamera) {\n      throw new Error('Invalid camera passed to the ProjectedMaterial');\n    } // make sure the camera matrices are updated\n\n\n    camera.updateProjectionMatrix();\n    camera.updateMatrixWorld();\n    camera.updateWorldMatrix(); // get the matrices from the camera so they're fixed in camera's original position\n\n    var viewMatrixCamera = camera.matrixWorldInverse.clone();\n    var projectionMatrixCamera = camera.projectionMatrix.clone();\n    var modelMatrixCamera = camera.matrixWorld.clone();\n    var projPosition = camera.position.clone();\n    console.log(texture);\n    _this = _THREE$ShaderMaterial.call(this, _objectSpread({}, options, {\n      uniforms: {\n        color: {\n          value: new THREE.Color(color)\n        },\n        texture: {\n          value: texture\n        },\n        viewMatrixCamera: {\n          type: 'm4',\n          value: viewMatrixCamera\n        },\n        projectionMatrixCamera: {\n          type: 'm4',\n          value: projectionMatrixCamera\n        },\n        modelMatrixCamera: {\n          type: 'mat4',\n          value: modelMatrixCamera\n        },\n        // we will set this later when we will have positioned the object\n        savedModelMatrix: {\n          type: 'mat4',\n          value: new THREE.Matrix4()\n        },\n        projPosition: {\n          type: 'v3',\n          value: projPosition\n        }\n      },\n      vertexShader: \"\\n          uniform mat4 savedModelMatrix;\\n          uniform mat4 viewMatrixCamera;\\n          uniform mat4 projectionMatrixCamera;\\n          uniform mat4 modelMatrixCamera;\\n\\n          varying vec4 vWorldPosition;\\n          varying vec3 vNormal;\\n          varying vec4 vTexCoords;\\n\\n\\n          void main() {\\n            vNormal = mat3(savedModelMatrix) * normal;\\n            vWorldPosition = savedModelMatrix * vec4(position, 1.0);\\n            vTexCoords = projectionMatrixCamera * viewMatrixCamera * vWorldPosition;\\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          }\\n        \",\n      fragmentShader: \"\\n        uniform vec3 color;\\n        uniform sampler2D texture;\\n        uniform vec3 projPosition;\\n\\n        varying vec3 vNormal;\\n        varying vec4 vWorldPosition;\\n        varying vec4 vTexCoords;\\n        \\n        void main() {\\n          vec2 uv = (vTexCoords.xy / vTexCoords.w) * 0.5 + 0.5;\\n\\n          vec4 outColor = texture2D(texture, uv);\\n\\n          // this makes sure we don't render also the back of the object\\n          vec3 projectorDirection = normalize(projPosition - vWorldPosition.xyz);\\n          float dotProduct = dot(vNormal, projectorDirection);\\n          if (dotProduct < 0.0) {\\n            outColor = vec4(color, 1.0);\\n          }\\n\\n          gl_FragColor = outColor;\\n        }\\n      \"\n    })) || this;\n    _this.isProjectedMaterial = true;\n    return _this;\n  }\n\n  return ProjectedMaterial;\n}(THREE.ShaderMaterial);\n\nAFRAME.registerComponent('my-shader', {\n  schema: {\n    camera: {\n      type: 'selector'\n    },\n    texture: {\n      type: 'asset'\n    }\n  },\n  init: function () {\n    var _this2 = this;\n\n    var camera = this.data.camera.object3D.children[0];\n    var t = new THREE.TextureLoader().load(\"images/texture.png\", function (t) {\n      console.log(t);\n      _this2.el.getObject3D('mesh').material = new ProjectedMaterial({\n        camera: camera,\n        texture: t,\n        color: '#37E140'\n      });\n      /*\n      this.el.getObject3D('mesh').material = new THREE.MeshBasicMaterial({\n                              color: 0xFF8844,\n                              map: t,\n                              });\n                              */\n    });\n  }\n}); //shader\n\n/*\nAFRAME.registerShader('offset-repeat', {\n        schema: {\n            // the texture source (probably a video)\n            src: {type: 'map', is: 'uniform'},\n            // texture parameters\n            offset: {type: 'vec2', default: {x: 0, y: 0}, is: 'uniform'},\n            repeat: {type: 'vec2', default: {x: 1, y: 1}, is: 'uniform'}\n        },\n\n        init: function(data) {\n            data = AFRAME.utils.extend({}, data);\n            this.material = new THREE.MeshBasicMaterial({color: 0xFF8844});\n        },\n\n        vertexShader: [\n          'varying vec2 vUV;',\n          'void main(void) {',\n          '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n          '  vUV = uv;',\n          '}'\n        ].join('\\n'),\n\n        fragmentShader: [\n          'uniform sampler2D map;',\n          'uniform vec2 offset;',\n          'uniform vec2 repeat;',\n          'varying vec2 vUV;',\n          'void main() {',\n          '  gl_FragColor = texture2D(map, vec2(vUV.x / repeat.x + offset.x, vUV.y / repeat.y + offset.y));',\n          '}'\n        ].join('\\n')\n    });\n\n*/\n//Vue\n\nmodule.exportDefault({\n  name: \"SceneTest\",\n  components: {\n    Object: Object,\n    Model: Model\n  },\n  data: function () {\n    return {\n      start: false\n    };\n  },\n  mounted: function () {},\n  meteor: {},\n  components: {},\n  methods: {},\n  watch: {},\n  computed: {}\n});","map":{"version":3,"sources":["/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue"],"names":["_objectSpread","module","link","default","v","_objectWithoutProperties","_inheritsLoose","Vue","Aframe","Object","Model","config","ignoredElements","ProjectedMaterial","camera","texture","color","options","isTexture","Error","isCamera","updateProjectionMatrix","updateMatrixWorld","updateWorldMatrix","viewMatrixCamera","matrixWorldInverse","clone","projectionMatrixCamera","projectionMatrix","modelMatrixCamera","matrixWorld","projPosition","position","console","log","uniforms","value","THREE","Color","type","savedModelMatrix","Matrix4","vertexShader","fragmentShader","isProjectedMaterial","ShaderMaterial","AFRAME","registerComponent","schema","init","data","object3D","children","t","TextureLoader","load","el","getObject3D","material","exportDefault","name","components","start","mounted","meteor","methods","watch","computed"],"mappings":"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","sourcesContent":["\n\n\n//Vue\nimport Vue from \"vue\";\nVue.config.ignoredElements = [\n  'a-scene',\n  'a-entity',\n  'a-camera',\n  'a-box',\n  'a-sky',\n  'a-sphere',\n  'a-cylinder',\n  'a-plane',\n  'a-gltf-model',\n];\n\n\n//Aframe\nimport {Aframe} from \"aframe\"\n\n\nclass ProjectedMaterial extends THREE.ShaderMaterial {\n  constructor({ camera, texture, color = 0xffffff, ...options } = {}) {\n    if (!texture || !texture.isTexture) {\n      throw new Error('Invalid texture passed to the ProjectedMaterial')\n    }\n\n    if (!camera || !camera.isCamera) {\n      throw new Error('Invalid camera passed to the ProjectedMaterial')\n    }\n\n    // make sure the camera matrices are updated\n    camera.updateProjectionMatrix()\n    camera.updateMatrixWorld()\n    camera.updateWorldMatrix()\n\n    // get the matrices from the camera so they're fixed in camera's original position\n    const viewMatrixCamera = camera.matrixWorldInverse.clone()\n    const projectionMatrixCamera = camera.projectionMatrix.clone()\n    const modelMatrixCamera = camera.matrixWorld.clone()\n\n    const projPosition = camera.position.clone()\n\n    console.log(texture)\n\n    super({\n      ...options,\n      uniforms: {\n        color: { value: new THREE.Color(color) },\n        texture: { value: texture },\n        viewMatrixCamera: { type: 'm4', value: viewMatrixCamera },\n        projectionMatrixCamera: { type: 'm4', value: projectionMatrixCamera },\n        modelMatrixCamera: { type: 'mat4', value: modelMatrixCamera },\n        // we will set this later when we will have positioned the object\n        savedModelMatrix: { type: 'mat4', value: new THREE.Matrix4() },\n        projPosition: { type: 'v3', value: projPosition },\n      },\n\n      vertexShader: `\n          uniform mat4 savedModelMatrix;\n          uniform mat4 viewMatrixCamera;\n          uniform mat4 projectionMatrixCamera;\n          uniform mat4 modelMatrixCamera;\n\n          varying vec4 vWorldPosition;\n          varying vec3 vNormal;\n          varying vec4 vTexCoords;\n\n\n          void main() {\n            vNormal = mat3(savedModelMatrix) * normal;\n            vWorldPosition = savedModelMatrix * vec4(position, 1.0);\n            vTexCoords = projectionMatrixCamera * viewMatrixCamera * vWorldPosition;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          }\n        `,\n\n      fragmentShader: `\n        uniform vec3 color;\n        uniform sampler2D texture;\n        uniform vec3 projPosition;\n\n        varying vec3 vNormal;\n        varying vec4 vWorldPosition;\n        varying vec4 vTexCoords;\n        \n        void main() {\n          vec2 uv = (vTexCoords.xy / vTexCoords.w) * 0.5 + 0.5;\n\n          vec4 outColor = texture2D(texture, uv);\n\n          // this makes sure we don't render also the back of the object\n          vec3 projectorDirection = normalize(projPosition - vWorldPosition.xyz);\n          float dotProduct = dot(vNormal, projectorDirection);\n          if (dotProduct < 0.0) {\n            outColor = vec4(color, 1.0);\n          }\n\n          gl_FragColor = outColor;\n        }\n      `,\n    })\n\n    this.isProjectedMaterial = true\n  }\n}\n\n\nAFRAME.registerComponent('my-shader', {\n    schema: {\n        camera: {\n            type:'selector'\n        },\n\n        texture: {\n            type:'asset'\n        }\n    },\n\n    init:function() {\n        \n        let camera = this.data.camera.object3D.children[0];\n        let t = new THREE.TextureLoader().load( \n            \"images/texture.png\",\n            ( t ) => {\n                console.log(t)\n                this.el.getObject3D('mesh').material = new ProjectedMaterial({camera, texture:t, color: '#37E140',});\n                /*\n                this.el.getObject3D('mesh').material = new THREE.MeshBasicMaterial({\n                                        color: 0xFF8844,\n                                        map: t,\n                                        });\n                                        */\n\t\t    } \n        );\n\n\n    }\n});\n\n\n\n\n//shader\n/*\nAFRAME.registerShader('offset-repeat', {\n        schema: {\n            // the texture source (probably a video)\n            src: {type: 'map', is: 'uniform'},\n            // texture parameters\n            offset: {type: 'vec2', default: {x: 0, y: 0}, is: 'uniform'},\n            repeat: {type: 'vec2', default: {x: 1, y: 1}, is: 'uniform'}\n        },\n\n        init: function(data) {\n            data = AFRAME.utils.extend({}, data);\n            this.material = new THREE.MeshBasicMaterial({color: 0xFF8844});\n        },\n\n        vertexShader: [\n          'varying vec2 vUV;',\n          'void main(void) {',\n          '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n          '  vUV = uv;',\n          '}'\n        ].join('\\n'),\n\n        fragmentShader: [\n          'uniform sampler2D map;',\n          'uniform vec2 offset;',\n          'uniform vec2 repeat;',\n          'varying vec2 vUV;',\n          'void main() {',\n          '  gl_FragColor = texture2D(map, vec2(vUV.x / repeat.x + offset.x, vUV.y / repeat.y + offset.y));',\n          '}'\n        ].join('\\n')\n    });\n\n*/\n\n\n\n\n//Vue\nimport Object from \"./Object.vue\";\nimport Model from \"./Model.vue\";\n\n\nexport default {\n  name: \"SceneTest\",\n\n  components: {\n    Object,\n    Model,\n  },\n\n \n  data() {\n    \n    return {\n        start:false,\n    }\n  },\n\n  mounted(){\n\n  },\n\n  meteor: {\n  },\n\n  components: {\n  },\n\n  methods: {\n\n  \n   \n  },\n\n  watch: {\n  },\n\n  computed: {\n    \n  }\n\n  \n};\n\n"]},"sourceType":"module","hash":"feb12ed6869b404c74f53c72446a1f617dbc325c"}
