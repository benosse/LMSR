{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions",["flow",{}],"nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}]],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"sourceFileName":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","filename":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","passPerPreset":false,"envName":"development","cwd":"/home/benoit/Documents/TutoMeteor","root":"/home/benoit/Documents/TutoMeteor","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.7.6","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"TSModuleBlock":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue"}},"code":"var _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default: function (v) {\n    _objectSpread = v;\n  }\n}, 0);\n\nvar _objectWithoutProperties;\n\nmodule.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n  default: function (v) {\n    _objectWithoutProperties = v;\n  }\n}, 1);\n\nvar _inheritsLoose;\n\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 2);\nvar Vue;\nmodule.link(\"vue\", {\n  \"default\": function (v) {\n    Vue = v;\n  }\n}, 0);\nvar Aframe;\nmodule.link(\"aframe\", {\n  Aframe: function (v) {\n    Aframe = v;\n  }\n}, 1);\nvar Object;\nmodule.link(\"./Object.vue\", {\n  \"default\": function (v) {\n    Object = v;\n  }\n}, 2);\nvar Model;\nmodule.link(\"./Model.vue\", {\n  \"default\": function (v) {\n    Model = v;\n  }\n}, 3);\nVue.config.ignoredElements = ['a-scene', 'a-entity', 'a-camera', 'a-box', 'a-sky', 'a-sphere', 'a-cylinder', 'a-plane', 'a-gltf-model']; //Aframe\n\nvar NoClickLookControls = require('aframe-no-click-look-controls');\n\nAFRAME.registerComponent('no-click-look-controls', NoClickLookControls);\nAFRAME.registerComponent('mask', {\n  init: function () {\n    //création du materiau, TODO: créer une fois pour toute ailleurs??\n    var mat = new THREE.MeshBasicMaterial({\n      colorWrite: false\n    }); //si c'est une primitive\n\n    var mesh = this.el.getObject3D('mesh');\n    if (mesh) mesh.material = mat; // si c'est un gltf\n\n    this.el.addEventListener('model-loaded', function (e) {\n      console.log(\"modèle chargé\"); //applique le masque à tous les meshs et sous-meshs\n\n      e.detail.model.traverse(function (node) {\n        if (node.isMesh) {\n          node.material = mat;\n        }\n      });\n    });\n  }\n});\n\nvar ProjectedMaterial =\n/*#__PURE__*/\nfunction (_THREE$ShaderMaterial) {\n  _inheritsLoose(ProjectedMaterial, _THREE$ShaderMaterial);\n\n  function ProjectedMaterial() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var camera = _ref.camera,\n        texture = _ref.texture,\n        _ref$color = _ref.color,\n        color = _ref$color === void 0 ? 0xffffff : _ref$color,\n        options = _objectWithoutProperties(_ref, [\"camera\", \"texture\", \"color\"]);\n\n    if (!texture || !texture.isTexture) {\n      throw new Error('Invalid texture passed to the ProjectedMaterial');\n    }\n\n    if (!camera || !camera.isCamera) {\n      throw new Error('Invalid camera passed to the ProjectedMaterial');\n    } // make sure the camera matrices are updated\n\n\n    camera.updateProjectionMatrix();\n    camera.updateMatrixWorld();\n    camera.updateWorldMatrix(); // get the matrices from the camera so they're fixed in camera's original position\n\n    var viewMatrixCamera = camera.matrixWorldInverse.clone();\n    var projectionMatrixCamera = camera.projectionMatrix.clone();\n    var modelMatrixCamera = camera.matrixWorld.clone();\n    var projPosition = camera.position.clone();\n    console.log(\"shader\", texture);\n    _this = _THREE$ShaderMaterial.call(this, _objectSpread({}, options, {\n      uniforms: {\n        color: {\n          value: new THREE.Color(color)\n        },\n        map: {\n          type: 't',\n          value: texture\n        },\n        viewMatrixCamera: {\n          type: 'm4',\n          value: viewMatrixCamera\n        },\n        projectionMatrixCamera: {\n          type: 'm4',\n          value: projectionMatrixCamera\n        },\n        modelMatrixCamera: {\n          type: 'mat4',\n          value: modelMatrixCamera\n        },\n        // we will set this later when we will have positioned the object\n        savedModelMatrix: {\n          type: 'mat4',\n          value: new THREE.Matrix4()\n        },\n        projPosition: {\n          type: 'v3',\n          value: projPosition\n        }\n      },\n      vertexShader: \"\\n          uniform mat4 viewMatrixCamera;\\n          uniform mat4 projectionMatrixCamera;\\n          uniform mat4 modelMatrixCamera;\\n\\n          varying vec4 vWorldPosition;\\n          varying vec3 vNormal;\\n          varying vec4 vTexCoords;\\n\\n\\n          void main() {\\n            vNormal = mat3(modelMatrix) * normal;\\n            vWorldPosition = modelMatrix * vec4(position, 1.0);\\n            vTexCoords = projectionMatrixCamera * viewMatrixCamera * vWorldPosition;\\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          }\\n        \",\n      fragmentShader: \"\\n        uniform vec3 color;\\n        uniform sampler2D map;\\n        uniform vec3 projPosition;\\n\\n        varying vec3 vNormal;\\n        varying vec4 vWorldPosition;\\n        varying vec4 vTexCoords;\\n        \\n        void main() {\\n          vec2 uv = (vTexCoords.xy / vTexCoords.w) * 0.5 + 0.5;\\n\\n          vec4 outColor = texture(map, uv);\\n\\n          // this makes sure we don't render the texture also on the back of the object\\n          vec3 projectorDirection = normalize(projPosition - vWorldPosition.xyz);\\n          float dotProduct = dot(vNormal, projectorDirection);\\n          \\n\\n          gl_FragColor = outColor;\\n        }\\n      \"\n    })) || this;\n    _this.isProjectedMaterial = true;\n    return _this;\n  }\n\n  return ProjectedMaterial;\n}(THREE.ShaderMaterial);\n\nAFRAME.registerComponent('my-shader', {\n  schema: {\n    camera: {\n      type: 'selector'\n    },\n    src: {\n      type: 'string'\n    }\n  },\n  init: function () {\n    var _this2 = this;\n\n    var camera = this.data.camera.object3D.children[0];\n    var src = this.data.src;\n    var t = new THREE.TextureLoader().load(src, function (t) {\n      console.log(t);\n      _this2.el.getObject3D('mesh').material = new ProjectedMaterial({\n        camera: camera,\n        texture: t,\n        color: '#37E140'\n      });\n      /*\n      this.el.getObject3D('mesh').material = new THREE.MeshBasicMaterial({\n                              color: 0xFF8844,\n                              map: t,\n                              });\n                              */\n    });\n  }\n});\nAFRAME.registerShader('offset-repeat', {\n  schema: {\n    // the texture source (probably a video)\n    src: {\n      type: 'map'\n    },\n    // texture parameters\n    offset: {\n      type: 'vec2',\n      \"default\": {\n        x: 0,\n        y: 0\n      }\n    },\n    repeat: {\n      type: 'vec2',\n      \"default\": {\n        x: 1,\n        y: 1\n      }\n    }\n  },\n  uniforms: {\n    // the texture value (once the texture source is loaded, update)\n    map: {\n      type: 't',\n      value: null\n    },\n    // texture parameters\n    offset: {\n      type: 'vec2',\n      value: {\n        x: 0,\n        y: 0\n      }\n    },\n    repeat: {\n      type: 'vec2',\n      value: {\n        x: 1,\n        y: 1\n      }\n    }\n  },\n  init: function (data) {\n    this.material = new THREE.MeshBasicMaterial({\n      color: 0xFF8844\n    });\n    /*\n    this.material = new THREE.ShaderMaterial({\n         uniforms: this.uniforms,\n         vertexShader: this.vertexShader,\n         fragmentShader: this.fragmentShader\n     });\n    */\n  },\n  update: function (data) {\n    AFRAME.utils.material.updateMap(this, data);\n    this.uniforms.map.value = this.material.map;\n    this.uniforms.offset.value = data.offset;\n    this.uniforms.repeat.value = data.repeat;\n  },\n  vertexShader: ['varying vec2 vUV;', 'void main(void) {', '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '  vUV = uv;', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D map;', 'uniform vec2 offset;', 'uniform vec2 repeat;', 'varying vec2 vUV;', 'void main() {', '  gl_FragColor = texture2D(map, vec2(vUV.x / repeat.x + offset.x, vUV.y / repeat.y + offset.y));', '}'].join('\\n')\n}); //shader\n\n/*\nAFRAME.registerShader('offset-repeat', {\n        schema: {\n            // the texture source (probably a video)\n            src: {type: 'map', is: 'uniform'},\n            // texture parameters\n            offset: {type: 'vec2', default: {x: 0, y: 0}, is: 'uniform'},\n            repeat: {type: 'vec2', default: {x: 1, y: 1}, is: 'uniform'}\n        },\n\n        init: function(data) {\n            data = AFRAME.utils.extend({}, data);\n            this.material = new THREE.MeshBasicMaterial({color: 0xFF8844});\n        },\n\n        vertexShader: [\n          'varying vec2 vUV;',\n          'void main(void) {',\n          '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n          '  vUV = uv;',\n          '}'\n        ].join('\\n'),\n\n        fragmentShader: [\n          'uniform sampler2D map;',\n          'uniform vec2 offset;',\n          'uniform vec2 repeat;',\n          'varying vec2 vUV;',\n          'void main() {',\n          '  gl_FragColor = texture2D(map, vec2(vUV.x / repeat.x + offset.x, vUV.y / repeat.y + offset.y));',\n          '}'\n        ].join('\\n')\n    });\n\n*/\n//Vue\n\nmodule.exportDefault({\n  name: \"SceneTest\",\n  components: {\n    Object: Object,\n    Model: Model\n  },\n  data: function () {\n    return {\n      start: false,\n      bibli: {\n        hovering: false,\n        position: \"0 0 0\",\n        rotation: \"0 0 0\",\n        src: \"/bibli.glb\",\n        imgSrc: \"/images/mur.png\",\n        animation: \"0 1 0\"\n      }\n    };\n  },\n  mounted: function () {},\n  meteor: {},\n  components: {},\n  methods: {\n    onMouseEnter: function (src) {\n      this.imageSrc = src;\n    },\n    onMouseLeave: function () {\n      this.imageSrc = \"/images/logo.png\";\n    }\n  },\n  watch: {},\n  computed: {}\n});","map":{"version":3,"sources":["/home/benoit/Documents/TutoMeteor/client/components/SceneTest.vue"],"names":["_objectSpread","module","link","default","v","_objectWithoutProperties","_inheritsLoose","Vue","Aframe","Object","Model","config","ignoredElements","NoClickLookControls","require","AFRAME","registerComponent","init","mat","THREE","MeshBasicMaterial","colorWrite","mesh","el","getObject3D","material","addEventListener","e","console","log","detail","model","traverse","node","isMesh","ProjectedMaterial","camera","texture","color","options","isTexture","Error","isCamera","updateProjectionMatrix","updateMatrixWorld","updateWorldMatrix","viewMatrixCamera","matrixWorldInverse","clone","projectionMatrixCamera","projectionMatrix","modelMatrixCamera","matrixWorld","projPosition","position","uniforms","value","Color","map","type","savedModelMatrix","Matrix4","vertexShader","fragmentShader","isProjectedMaterial","ShaderMaterial","schema","src","data","object3D","children","t","TextureLoader","load","registerShader","offset","x","y","repeat","update","utils","updateMap","join","exportDefault","name","components","start","bibli","hovering","rotation","imgSrc","animation","mounted","meteor","methods","onMouseEnter","imageSrc","onMouseLeave","watch","computed"],"mappings":"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","sourcesContent":["\n\n\n//Vue\nimport Vue from \"vue\";\nVue.config.ignoredElements = [\n  'a-scene',\n  'a-entity',\n  'a-camera',\n  'a-box',\n  'a-sky',\n  'a-sphere',\n  'a-cylinder',\n  'a-plane',\n  'a-gltf-model',\n];\n\n\n//Aframe\nimport {Aframe} from \"aframe\"\n\nvar NoClickLookControls = require('aframe-no-click-look-controls');\nAFRAME.registerComponent('no-click-look-controls', NoClickLookControls);\n\nAFRAME.registerComponent('mask', {\n\n    init: function() {\n\n        //création du materiau, TODO: créer une fois pour toute ailleurs??\n        const mat = new THREE.MeshBasicMaterial({\n            colorWrite: false\n        })\n\n        //si c'est une primitive\n        let mesh = this.el.getObject3D('mesh');\n        if (mesh)\n            mesh.material = mat;\n\n        // si c'est un gltf\n        this.el.addEventListener('model-loaded', function (e) {\n            console.log(\"modèle chargé\")\n\n            //applique le masque à tous les meshs et sous-meshs\n            e.detail.model.traverse(function(node) {\n                if (node.isMesh) {\n                    node.material = mat;\n                }\n            });\n         });\n    }\n})\n\n\n\nclass ProjectedMaterial extends THREE.ShaderMaterial {\n  constructor({ camera, texture, color = 0xffffff, ...options } = {}) {\n    if (!texture || !texture.isTexture) {\n      throw new Error('Invalid texture passed to the ProjectedMaterial')\n    }\n\n    if (!camera || !camera.isCamera) {\n      throw new Error('Invalid camera passed to the ProjectedMaterial')\n    }\n\n    // make sure the camera matrices are updated\n    camera.updateProjectionMatrix()\n    camera.updateMatrixWorld()\n    camera.updateWorldMatrix()\n\n    // get the matrices from the camera so they're fixed in camera's original position\n    const viewMatrixCamera = camera.matrixWorldInverse.clone()\n    const projectionMatrixCamera = camera.projectionMatrix.clone()\n    const modelMatrixCamera = camera.matrixWorld.clone()\n\n    const projPosition = camera.position.clone()\n\n    console.log(\"shader\",texture)\n\n    super({\n      ...options,\n      uniforms: {\n        color: { value: new THREE.Color(color) },\n        map: { type:'t', value:texture },\n        \n        viewMatrixCamera: { type: 'm4', value: viewMatrixCamera },\n        projectionMatrixCamera: { type: 'm4', value: projectionMatrixCamera },\n        modelMatrixCamera: { type: 'mat4', value: modelMatrixCamera },\n        // we will set this later when we will have positioned the object\n        savedModelMatrix: { type: 'mat4', value: new THREE.Matrix4() },\n        projPosition: { type: 'v3', value: projPosition },\n      },\n\n      vertexShader: `\n          uniform mat4 viewMatrixCamera;\n          uniform mat4 projectionMatrixCamera;\n          uniform mat4 modelMatrixCamera;\n\n          varying vec4 vWorldPosition;\n          varying vec3 vNormal;\n          varying vec4 vTexCoords;\n\n\n          void main() {\n            vNormal = mat3(modelMatrix) * normal;\n            vWorldPosition = modelMatrix * vec4(position, 1.0);\n            vTexCoords = projectionMatrixCamera * viewMatrixCamera * vWorldPosition;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          }\n        `,\n\n      fragmentShader: `\n        uniform vec3 color;\n        uniform sampler2D map;\n        uniform vec3 projPosition;\n\n        varying vec3 vNormal;\n        varying vec4 vWorldPosition;\n        varying vec4 vTexCoords;\n        \n        void main() {\n          vec2 uv = (vTexCoords.xy / vTexCoords.w) * 0.5 + 0.5;\n\n          vec4 outColor = texture(map, uv);\n\n          // this makes sure we don't render the texture also on the back of the object\n          vec3 projectorDirection = normalize(projPosition - vWorldPosition.xyz);\n          float dotProduct = dot(vNormal, projectorDirection);\n          \n\n          gl_FragColor = outColor;\n        }\n      `,\n\n    })\n\n    this.isProjectedMaterial = true\n  }\n}\n\n\nAFRAME.registerComponent('my-shader', {\n    schema: {\n        camera: {\n            type:'selector'\n        },\n\n        src: {\n            type:'string'\n        }\n    },\n\n    init:function() {\n        \n        let camera = this.data.camera.object3D.children[0];\n        let src = this.data.src;\n\n\n        let t = new THREE.TextureLoader().load( \n            src,\n            ( t ) => {\n                console.log(t)\n                this.el.getObject3D('mesh').material = new ProjectedMaterial({camera, texture:t, color: '#37E140',});\n                /*\n                this.el.getObject3D('mesh').material = new THREE.MeshBasicMaterial({\n                                        color: 0xFF8844,\n                                        map: t,\n                                        });\n                                        */\n                                        \n\t\t    } \n        );\n\n\n    }\n});\n\n\nAFRAME.registerShader('offset-repeat', {\n        schema: {\n            // the texture source (probably a video)\n            src: {type: 'map'},\n            // texture parameters\n            offset: {type: 'vec2', default: {x: 0, y: 0}},\n            repeat: {type: 'vec2', default: {x: 1, y: 1}}\n        },\n\n        uniforms: {\n            // the texture value (once the texture source is loaded, update)\n            map: { type: 't', value: null },\n            // texture parameters\n            offset: {type: 'vec2', value: {x: 0, y: 0}},\n            repeat: {type: 'vec2', value: {x: 1, y: 1}}\n        },\n\n        init: function(data) {\n            this.material = new THREE.MeshBasicMaterial({color: 0xFF8844});\n            /*\n            this.material = new THREE.ShaderMaterial({\n\n                uniforms: this.uniforms,\n\n                vertexShader: this.vertexShader,\n\n                fragmentShader: this.fragmentShader\n\n            });\n            */\n        },\n\n\n\n        update: function (data) {\n            AFRAME.utils.material.updateMap(this, data);\n            this.uniforms.map.value = this.material.map;\n            this.uniforms.offset.value = data.offset;\n            this.uniforms.repeat.value = data.repeat;\n        },\n\n\n\n        vertexShader: [\n          'varying vec2 vUV;',\n          'void main(void) {',\n          '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n          '  vUV = uv;',\n          '}'\n        ].join('\\n'),\n\n        fragmentShader: [\n          'uniform sampler2D map;',\n          'uniform vec2 offset;',\n          'uniform vec2 repeat;',\n          'varying vec2 vUV;',\n          'void main() {',\n          '  gl_FragColor = texture2D(map, vec2(vUV.x / repeat.x + offset.x, vUV.y / repeat.y + offset.y));',\n          '}'\n        ].join('\\n')\n    });\n\n//shader\n/*\nAFRAME.registerShader('offset-repeat', {\n        schema: {\n            // the texture source (probably a video)\n            src: {type: 'map', is: 'uniform'},\n            // texture parameters\n            offset: {type: 'vec2', default: {x: 0, y: 0}, is: 'uniform'},\n            repeat: {type: 'vec2', default: {x: 1, y: 1}, is: 'uniform'}\n        },\n\n        init: function(data) {\n            data = AFRAME.utils.extend({}, data);\n            this.material = new THREE.MeshBasicMaterial({color: 0xFF8844});\n        },\n\n        vertexShader: [\n          'varying vec2 vUV;',\n          'void main(void) {',\n          '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n          '  vUV = uv;',\n          '}'\n        ].join('\\n'),\n\n        fragmentShader: [\n          'uniform sampler2D map;',\n          'uniform vec2 offset;',\n          'uniform vec2 repeat;',\n          'varying vec2 vUV;',\n          'void main() {',\n          '  gl_FragColor = texture2D(map, vec2(vUV.x / repeat.x + offset.x, vUV.y / repeat.y + offset.y));',\n          '}'\n        ].join('\\n')\n    });\n\n*/\n\n\n\n\n//Vue\nimport Object from \"./Object.vue\";\nimport Model from \"./Model.vue\";\n\n\nexport default {\n  name: \"SceneTest\",\n\n  components: {\n    Object,\n    Model,\n  },\n\n \n  data() {\n    \n    return {\n        start:false,\n\n        bibli: {\n            hovering:false,\n            position:\"0 0 0\",\n            rotation:\"0 0 0\",\n            src:\"/bibli.glb\",\n            imgSrc:\"/images/mur.png\",\n            animation:\"0 1 0\",\n        },\n\n    }\n  },\n\n  mounted(){\n\n  },\n\n  meteor: {\n  },\n\n  components: {\n  },\n\n  methods: {\n\n    onMouseEnter(src) {\n      this.imageSrc = src;\n    },\n    onMouseLeave() {\n      this.imageSrc = \"/images/logo.png\"\n    },\n   \n  },\n\n  watch: {\n  },\n\n  computed: {\n    \n  }\n\n  \n};\n\n"]},"sourceType":"module","hash":"1c922b2e95eef0800388fa9a628a6450c230fe26"}
